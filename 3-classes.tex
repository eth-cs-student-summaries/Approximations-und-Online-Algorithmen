\section{Klassifizierung von Optimierungsproblemen}

Siehe auch [ASP].

\paragraph{NPO}
$U = (L, M, cost, goal) \in NPO$ falls folgende Operationen polynomiell sind:

(1) Lesen der Eingabe/Ausgabe, (2) Verifizieren der Eingabe/Ausgabe auf Zulässigkeit,
(3) Berechnen der Kosten einer Lösung.

\paragraph{PO} Falls eine optimale Lösung in Polynomzeit berechen bar ist. $PO \subseteq NPO$.

\paragraph{Schwellwertsprache}
Sprache von Entscheidungsproblemen.
$$ Lang_U = \{ (I,k) \st I \in L, k \in \N, Opt_U(I) \lesseqgtr  k\} $$

\paragraph{NP-schwer (Optimierungsproblem)} \mbox{}\\
Optimierungsproblem $U$ heisst NP-schwer $\iff$ Entscheidungsproblem $Lang_U$ ist NP-schwer

NP-Vollständigkeit macht keinen Sinn für Optimierungsprobleme.

\paragraph{Approximationsklassen} \mbox{}
\begin{table}[h]
    \centering
    \begin{tabular}{lll}
    Klasse & Enthält Probleme falls... & Beispiele \\ \hline
    PO & & \\
    FPTAS & $\exists$ ein FPTAS & KP \\
    PTAS & $\exists$ ein PTAS & SKP, Euklidisches TSP \\
    APX & $\exists$ Approximationsalg. mit konstanter Güte & Min-VCP, Max-CUT, $\Delta$-TSP \\
    LOGAPX & $\exists$ Approximationsalg. mit logarithmischer Güte & Min-SCP \\
    POLYAPX & $\exists$ Approximationsalg. mit polynomieller Güte & Max-CLIQUE \\
    NPO &  & TSP \\
    \end{tabular}
\end{table}
Beachte dass Approximationsalgorithmen in Polynomzeit laufen.
